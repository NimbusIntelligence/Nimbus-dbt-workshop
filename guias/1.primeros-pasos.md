# Primeros pasos con dbt Cloud

1. Haz clic en “Initialize dbt project” en el control de versiones

   ![Inicializar un Proyecto de dbt](../imagenes/inicializar_proyecto.png)

2. Haz clic en “Commit to new branch” en el control de versiones e introduce un mensaje de commit inicial en el cuadro de diálogo

   ![Commit y Sync](../imagenes/commit.png)

3. Haz clic en “Create branch” en el control de versiones y nómbralo “intro-training”

   ![Crear una Rama](../imagenes/crear_un_branch.png)

   ![Nombrar Rama](../imagenes/nombre_del_branch.png)

4. En la barra de comandos, ejecuta el siguiente comando:

   ```sh
   dbt run
   ```
   para crear todos los modelos en nuestro data warehouse.

5. Crea una nueva carpeta llamada lego dentro del directorio models (/models/lego).

6. Actualiza las líneas 38-43 del archivo dbt_project.yml para materializar todos los modelos en el directorio lego como tablas por defecto.

   ```yaml
   models:
     my_new_project:
       # Applies to all files under models/example/
       example:
         +materialized: table

       lego:
         +materialized: table
   ```

7. Crea un nuevo archivo dentro del directorio lego llamado parts_per_set.sql (/models/lego/parts_per_set.sql) y pega en el siguiente script:

   ```sql
   WITH UNIQUE_PARTS AS (
   SELECT
       P.part_num
   FROM dbt_workshop_db.lego.parts as P
   INNER JOIN dbt_workshop_db.lego.inventory_parts as IP on P.part_num = IP.part_num
   INNER JOIN dbt_workshop_db.lego.inventories as I on I.id = IP.inventory_id
   INNER JOIN dbt_workshop_db.lego.sets as S on S.set_num = I.set_num
       GROUP BY P.part_num
       HAVING COUNT(*) = 1
   )
   SELECT
       T.name as theme_name,
       S.name as set_name,
       S.year as set_year,
       CASE
           WHEN UP.part_num IS NULL THEN 'Not Unique'
           ELSE 'Unique'
       END as unique_part,
       COUNT(P.part_num) as parts
   FROM dbt_workshop_db.lego.parts as P
   LEFT JOIN UNIQUE_PARTS as UP on P.part_num = UP.part_num
   INNER JOIN dbt_workshop_db.lego.inventory_parts as IP on P.part_num = IP.part_num
   INNER JOIN dbt_workshop_db.lego.inventories as I on I.id = IP.inventory_id
   INNER JOIN dbt_workshop_db.lego.sets as S on S.set_num = I.set_num
   INNER JOIN dbt_workshop_db.lego.themes as T on T.id = S.theme_id
   GROUP BY 1,2,3,4;
   ```

8. En la barra de comandos, ejecuta el siguiente comando:

   ```sh
   dbt run --select parts_per_set
   ```

   para crear el modelo parts_per_set en nuestro data warehouse.

9. Elimina el punto y coma de la línea 26 en models/lego/parts_per_set.sql.

   ```sql
   GROUP BY 1,2,3,4
   ```

   <details>
   <summary>SQL Completo</summary>

   ```sql
   WITH UNIQUE_PARTS AS (
   SELECT
       P.part_num
   FROM dbt_workshop_db.lego.parts as P
   INNER JOIN dbt_workshop_db.lego.inventory_parts as IP on P.part_num = IP.part_num
   INNER JOIN dbt_workshop_db.lego.inventories as I on I.id = IP.inventory_id
   INNER JOIN dbt_workshop_db.lego.sets as S on S.set_num = I.set_num
       GROUP BY P.part_num
       HAVING COUNT(*) = 1
   )
   SELECT
       T.name as theme_name,
       S.name as set_name,
       S.year as set_year,
       CASE
           WHEN UP.part_num IS NULL THEN 'Not Unique'
           ELSE 'Unique'
       END as unique_part,
       COUNT(P.part_num) as parts
   FROM dbt_workshop_db.lego.parts as P
   LEFT JOIN UNIQUE_PARTS as UP on P.part_num = UP.part_num
   INNER JOIN dbt_workshop_db.lego.inventory_parts as IP on P.part_num = IP.part_num
   INNER JOIN dbt_workshop_db.lego.inventories as I on I.id = IP.inventory_id
   INNER JOIN dbt_workshop_db.lego.sets as S on S.set_num = I.set_num
   INNER JOIN dbt_workshop_db.lego.themes as T on T.id = S.theme_id
   GROUP BY 1,2,3,4
   ```

   </details>

10. En la barra de comandos, ejecuta el siguiente comando:

    ```sh
    dbt run --select lego
    ```

    para crear todos los modelos en la carpeta lego en nuestro data warehouse.

11. Crea un nuevo archivo dentro del directorio lego llamado sources.yml ("/models/lego/sources.yml") indicando a dbt dónde se encuentran las tablas fuente.

    ```yaml
    version: 2

    sources:
      - name: lego
        database: dbt_workshop_db
        schema: lego
        tables:
          - name: parts
          - name: inventory_parts
          - name: inventories
          - name: sets
          - name: themes
    ```

12. Edita parts_per_set.sql para reemplazar todos los nombres de tablas codificados con la función source.

    ```sql
    WITH UNIQUE_PARTS AS (
    SELECT
        P.part_num
    FROM {{ source('lego', 'parts') }} as P
    INNER JOIN {{ source('lego', 'inventory_parts') }} as IP on P.part_num = IP.part_num
    INNER JOIN {{ source('lego', 'inventories') }} as I on I.id = IP.inventory_id
    INNER JOIN {{ source('lego', 'sets') }} as S on S.set_num = I.set_num
        GROUP BY P.part_num
        HAVING COUNT(*) = 1
    )
    SELECT
        T.name as theme_name,
        S.name as set_name,
        S.year as set_year,
        CASE
            WHEN UP.part_num IS NULL THEN 'Not Unique'
            ELSE 'Unique'
        END as unique_part,
        COUNT(P.part_num) as parts
    FROM {{ source('lego', 'parts') }} as P
    LEFT JOIN UNIQUE_PARTS as UP on P.part_num = UP.part_num
    INNER JOIN {{ source('lego', 'inventory_parts') }} as IP on P.part_num = IP.part_num
    INNER JOIN {{ source('lego', 'inventories') }} as I on I.id = IP.inventory_id
    INNER JOIN {{ source('lego', 'sets') }} as S on S.set_num = I.set_num
    INNER JOIN {{ source('lego', 'themes') }} as T on T.id = S.theme_id
    GROUP BY 1,2,3,4
    ```

13. Crea un nuevo archivo en el directorio lego llamado unique_parts.sql ("/models/lego/unique_parts.sql").

14. Copia las líneas 2 a 9 de parts_per_set.sql en unique_parts.sql.

    ```sql
    SELECT
        P.part_num
    FROM {{ source('lego', 'parts') }} as P
    INNER JOIN {{ source('lego', 'inventory_parts') }} as IP on P.part_num = IP.part_num
    INNER JOIN {{ source('lego', 'inventories') }} as I on I.id = IP.inventory_id
    INNER JOIN {{ source('lego', 'sets') }} as S on S.set_num = I.set_num
        GROUP BY P.part_num
        HAVING COUNT(*) = 1
    ```

15. Agrega un bloque de configuración al inicio de unique_parts.sql para materializarlo como view en el data warehouse.

    ```sql
    {{
        config(
            materialized='view'
        )
    }}

    SELECT
        P.part_num
    FROM {{ source('lego', 'parts') }} as P
    INNER JOIN {{ source('lego', 'inventory_parts') }} as IP on P.part_num = IP.part_num
    INNER JOIN {{ source('lego', 'inventories') }} as I on I.id = IP.inventory_id
    INNER JOIN {{ source('lego', 'sets') }} as S on S.set_num = I.set_num
        GROUP BY P.part_num
        HAVING COUNT(*) = 1
    ```

16. Actualiza parts_per_set.sql para reemplazar el CTE (líneas 1-10) con la función ref() apuntando a unique_parts.sql.

    ```sql
    WITH UNIQUE_PARTS AS (
        SELECT *
        from {{ ref('unique_parts') }}
    )
    SELECT
        T.name as theme_name,
        S.name as set_name,
        S.year as set_year,
        CASE
            WHEN UP.part_num IS NULL THEN 'Not Unique'
            ELSE 'Unique'
        END as unique_part,
        COUNT(P.part_num) as parts
    FROM {{ source('lego', 'parts') }} as P
    LEFT JOIN UNIQUE_PARTS as UP on P.part_num = UP.part_num
    INNER JOIN {{ source('lego', 'inventory_parts') }} as IP on P.part_num = IP.part_num
    INNER JOIN {{ source('lego', 'inventories') }} as I on I.id = IP.inventory_id
    INNER JOIN {{ source('lego', 'sets') }} as S on S.set_num = I.set_num
    INNER JOIN {{ source('lego', 'themes') }} as T on T.id = S.theme_id
    GROUP BY 1,2,3,4
    ```

17. En la barra de comandos, ejecuta el comando:

    ```sh
    dbt run --select lego
    ```

    para crear los dos modelos de lego de manera secuencial en el data warehouse.

18. Crea un nuevo archivo dentro del directorio lego llamado schema.yml ("/models/lego/schema.yml") para agregar la documentación y las pruebas.

    ```yml
    version: 2

    models:
      - name: unique_parts
        description: The part_nums which are only used in one set
        columns:
          - name: part_num
            data_tests:
              - not_null

      - name: parts_per_set
        description: Shows the number of parts in each set along with their theme and whether they have unique parts
        columns:
          - name: theme_name
            data_tests:
              - not_null
          - name: set_name
            data_tests:
              - not_null
          - name: set_year
            data_tests:
              - not_null
    ```

19. En la barra de comandos, ejecuta el comando

    ```sh
    dbt build
    ```

    para crear y probar todos los modelos en nuestro data warehouse.

20. En la barra de comandos, ejecuta el comando

    ```sh
    dbt test
    ```

    para probar todos los modelos

21. Edita el archivo my_first_dbt_model.sql en el directorio de ejemplo (/models/example/my_first_dbt_model.sql) para eliminar el comentario en la línea 27.

    ```sql

    /*
        Welcome to your first dbt model!
        Did you know that you can also configure models directly within SQL files?
        This will override configurations stated in dbt_project.yml

        Try changing "table" to "view" below
    */

    {{ config(materialized='table') }}

    with source_data as (

        select 1 as id
        union all
        select null as id

    )

    select *
    from source_data

    /*
        Uncomment the line below to remove records with null `id` values
    */

    where id is not null

    ```

22. En la barra de comandos, ejecuta el comando:

    ```sh
    dbt build
    ```

    Para crear y probar todos los modelos en nuestro data warehouse., asegurándote de que todos pasen:

23. Actualiza el archivo sources.yml en el directorio lego (/models/lego/sources.yml) copiando y pegando la versión completa.

    ```yml
    version: 2

    sources:
      - name: lego
        database: DBT_WORKSHOP_DB
        schema: LEGO
        tables:
          - name: colors
            description: dimension table of lego colors
            columns:
              - name: id
                description: primary key and unique identifier of each color
                data_tests:
                  - not_null
                  - unique
              - name: name
                description: the name of the color
                data_tests:
                  - not_null
                  - unique
              - name: RGB
                description: the hex value of the color
                data_tests:
                  - not_null
              - name: is_trans
                data_tests:
                  - accepted_values:
                      values: ["TRUE", "FALSE"]

          - name: inventories
            description: dimension table of what we currently stock
            columns:
              - name: id
                description: primary key
                data_tests:
                  - unique
                  - not_null
              - name: version
                description: the version of each set we carry
                data_tests:
                  - not_null
              - name: set_num
                description: foreign key and the set identifier
                data_tests:
                  - not_null
                  - relationships:
                      to: source('lego','sets')
                      field: set_num

          - name: inventory_parts
            description: the parts within each set we stock
            columns:
              - name: inventory_id
                description: foreign key to inventories table
                data_tests:
                  - not_null
                  - relationships:
                      to: source('lego','inventories')
                      field: id
              - name: part_num
                description: foreign key to parts table - not behaving properly
                data_tests:
                  - not_null
              - name: color_id
                description: foreign key to colors table
                data_tests:
                  - not_null
                  - relationships:
                      to: source('lego','colors')
                      field: id
              - name: quantity
                description: how many of that part is in the set
                data_tests:
                  - not_null
              - name: is_spare
                description: boolean if the part is spare
                data_tests:
                  - not_null
                  - accepted_values:
                      values: ["TRUE", "FALSE"]

          - name: inventory_sets
            description: dimension table of sets and how many we stock
            columns:
              - name: inventory_id
                description: foreign key to inventories
                data_tests:
                  - not_null
                  - relationships:
                      to: source('lego','inventories')
                      field: id
              - name: set_num
                description: foreign key from sets
                data_tests:
                  - not_null
                  - relationships:
                      to: source('lego','sets')
                      field: set_num
              - name: quantity
                description: how many of each set we hold

          - name: parts
            description: dimension table of lego parts
            columns:
              - name: part_num
                description: primary key and unique identifier of each part
                data_tests:
                  - not_null
                  - unique
              - name: name
                description: the name of the part
                data_tests:
                  - not_null
              - name: part_cat_id
                description: foreign key from part_categories table
                data_tests:
                  - not_null
                  - relationships:
                      to: source('lego','part_categories')
                      field: id

          - name: part_categories
            description: dimension table combining parts into different categories
            columns:
              - name: id
                description: primary key
                data_tests:
                  - unique
                  - not_null
              - name: name
                description: the part category name
                data_tests:
                  - not_null

          - name: sets
            description: dimension table of all lego sets
            columns:
              - name: set_num
                description: primary key
                data_tests:
                  - not_null
                  - unique
              - name: name
                description: the name of the set
                data_tests:
                  - not_null
              - name: year
                description: the year the set was released
                data_tests:
                  - not_null
              - name: theme_id
                description: foreign key from themes
                data_tests:
                  - not_null
                  - relationships:
                      to: source('lego','themes')
                      field: id
              - name: num_parts
                description: the number of parts in each set
                data_tests:
                  - not_null

          - name: themes
            description: dimension table grouping sets into different themes
            columns:
              - name: id
                description: primary key
                data_tests:
                  - not_null
                  - unique
              - name: name
                description: the name of the theme
                data_tests:
                  - not_null
              - name: parent_id
                description: if a theme is a sub-theme, the id of its parent
                data_tests:
                  - relationships:
                      to: source('lego','themes')
                      field: id
    ```

    Esta versión completa contiene descripciones detalladas de las fuentes y sus columnas. También utiliza los 4 tests de datos integrados: not_null, unique, accepted_values y relationships.

24. En la barra de comandos, ejecuta el comando

    ```sh
    dbt build
    ```

    para crear y luego probar todos nuestros modelos de forma secuencial en el data warehouse.

25. En la barra de comandos, ejecuta el comando

    ```sh
    dbt docs generate
    ```

    para generar documentación basada en los modelos y archivos YAML de nuestro proyecto

26. Haz clic en el pequeño ícono de documento para ver la documentación

    ![docs icon](../imagenes/icono_docs.png)

27. Haz clic en "Commit and sync" en control de versiones e ingresa un mensaje de commit en el cuadro de diálogo.

    ![commit y sync](../imagenes/commit.png)

### [Lista de Guias](../ReadMe.md)
